/**
 * Initialization
 * =======================================================
 * 생성하면서 초기화 하라
 * 초기화되지 않은 변수를 사용하지 마라
 * 자동 제로 초기화에 의존하지 마라. 낭패볼 수 있다
 * 
 * Modern C++:
 *  C++11~: 중괄호 초기화를 제공하여 클래스인지, 배열인지, 구조체인지 구분없이
 *      중괄호 ({})를 이용하여 일관성 있게 초기화 할수 있으며, 초기화 파싱 오류도
 *      해결했습니다
 *  C++11~: 멤버 선언부 초기화가 추가되어 비정적 멤버 변수의 초기화가 쉬워젔습니다.
 *  C++17~: 임시 구체화와 복사 생략 보증을 통해 컴파일러 의존적이었던 생성자 호출 및
 *          함수 인수 전달 최적화, 리턴값 최적화등이 표준화 되었습니다.
 *  C++17~: 인라인 변수가 추가되어 헤더 파일에 정의된 변수를 여러개의 cpp 에서
 *           #include 하더라도 중복 저으이 없이 사용할수 있습니다. 또한, 클래스
 *           정적 멤버 변수를 선언부에서 초기화 할수 있습니다.
 *  C++20~: 지명 초기화가 추가되어 중괄호 집합 초기화시 변수명을 지며ㄴ하여 값을
 *           초기화 할수 있습니다.
 * 
 *   항목	          자동 제로 초기화 지원	    선언에서 명시적 초기화 지원	    권장 초기화 방법
 * ------------------------------------------------------------------------------------------- 
 *  전역 변수       	     O	                    O	                     선언시 초기화
 *  정적 전역 변수	         O	                    O	                     선언시 초기화
 *  정적 멤버 변수      	 O                  	X	                     사용 비권장. 함수내의 정적 지역 변수 사용
 *  정적 상수 멤버 변수  	 X	                     O	                     선언시 초기화 
 *  개체의 멤버 변수	     △	                    X	                    기본 생성자의 초기화 리스트. (new T;와 new T();가 달라서 △로 표기했습니다. 실수할 소지가 많으니 명시적으로 초기화 하세요.)
 *  함수내 정적 지역 변수	 O	                     O	                     선언시 초기화
 *  지역 변수            	X	                    O	                    선언시 초기화
 * 
 * */

/*  초기화 테스트용 클라스 */
class T {
public: 
    T() {}      
    explicit T(int t ) {}
    T(int x, int y) {}
    T(const T& other) {}

    void operator =(const T& other) {}
};

/* 값 초기화 */
T obj(1);       // (0) int 를 전달받은 생성자 호출
T obj(1,2);     // (0) 값 2개를 전달받는 생성자 호출

T obj = 1;      // (~) 비권장. T t(int x); 를 호출을 위한건지, 정수 1 을 T에 잘못 대입한 것인지 헷갈립니다.

T obj = T(1); // (△) 비권장. T(1)로 생성한 개체를 T obj 의 복사 생성자를 호출하여 생성합니다.
T obj(T(1)); // (△) 비권장. T(1)로 생성한 개체를 T obj 의 복사 생성자를 호출하여 생성합니다.

/*  복사 초기화     */
T other;

T obj1 = other;         // (0) 타입이 같다면 혹사 생성자가 호출됨
T obj2(other);          // (0) 명시적으로 복사 생성자 호출됨

int main(void) {

    int arr1[3];        // (~) 초기화 되지 안아 비권장
    // int arr1[];      // (x)  갯수가 지정되지 않음
    // int arr1p[] = {};// (x)  윗
    int arr2[] = {0, 1, 2}; // (0)
    int arr3[3] = {};   // (0) 3개 모두 0으로 초기화됨
    int arr4[3] = {0, 1, }; // (0) 갯수가 적거나 같아야 함. 모자라면 0
        
    EXPECT_TRUE(arr2[2] == 2);
    EXPECT_TRUE(arr3[0] == 0 && arr3[1] == 0 && arr3[2] == 0);
    EXPECT_TRUE(arr4[2] == 0);

    char str1[] = "abc"; // (O) {'a', `b`, 'c', '\0'};
    EXPECT_TRUE(str1[0] == 'a');
    EXPECT_TRUE(str1[1] == 'b');
    EXPECT_TRUE(str1[2] == 'c');
    EXPECT_TRUE(str1[3] == '\0'); // 널문자가 추가됨

    wchar_t str2[] = L"abc"; // (O) {L'a', L`b`, L'c', L'\0'};
    EXPECT_TRUE(str2[0] == L'a');
    EXPECT_TRUE(str2[1] == L'b');
    EXPECT_TRUE(str2[2] == L'c');
    EXPECT_TRUE(str2[3] == L'\0'); // 널문자가 추가됨



    /*  구조체 초기화  */
    struct T {int x; int y;} 
    T t = {10, 20}; 

    EXPECT_TRUE(t.x == 10 && t.y == 20);

    /*  자동 제로 초기화 */

    T t;
    T* ptr1 = new T; // 괄호 없이 생성합니다. 자동 초기화가 안됩니다.
    T* ptr2 = new T(); // 괄호로 생성합니다. 자동 초기화가 됩니다.

    EXPECT_TRUE(g_Val == 0); // 전역 변수는 0으로 자동 초기화
    EXPECT_TRUE(s_Val == 0); // 정적 전역 변수는 0으로 자동 초기화
    EXPECT_TRUE(T::s_m_Val == 0); // 정적 멤버 변수는 0으로 자동 초기화
    EXPECT_TRUE(T::s_c_m_Val == 0); // 정적 상수 멤버 변수는 명시적 초기화
    EXPECT_TRUE(ptr1->m_Val == 0 || ptr1->m_Val != 0); // new T; 로 생성하면 자동 초기화 되지 않습니다.
    EXPECT_TRUE(ptr2->m_Val == 0); // new T(); 로 생성하면 자동 초기화됩니다.
    EXPECT_TRUE(t.f1() == 0); // 정적 지역 변수는 0으로 자동 초기화
    // EXPECT_TRUE(t.f2() != 0); // 지역 변수는 쓰레기값이 될 수도 있음

    int arr[3] = {1, }; 
    EXPECT_TRUE(arr[0] == 1 && arr[1] == 0 && arr[2] == 0); // 배열 갯수 보다 초기화 갯수가 적을때 나머지 요소는 0으로 자동 초기화

    delete ptr1;
    delete ptr2;




    return 0;
}
